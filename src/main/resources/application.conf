akka {
  loglevel = INFO

  extensions = ["kamon.akka.Akka", "kamon.statsd.StatsD"]
}

# Kamon Metrics
# ~~~~~~~~~~~~~~

kamon {

  metric {

    # Time interval for collecting all metrics and send the snapshots to all subscribed actors.
    tick-interval = 10 seconds

    # Default size for the LongBuffer that gets allocated for metrics collection and merge. The
    # value should correspond to the highest number of different buckets with values that might
    # exist in a single histogram during a metrics collection. The default value of 33792 is a
    # very conservative value and its equal to the total number of buckets required to cover values
    # from 1 nanosecond to 1 hour with 0.1% precision (3 significant value digits). That means
    # that would need to have at least one measurement on every bucket of a single histogram to
    # fully utilize this buffer, which is *really* unlikely to ever happen. Since the buffer should
    # be allocated once and reused it shouldn't impose a memory footprint issue.
    default-collection-context-buffer-size = 33792

    # Disables a big error message that will be typically logged if your application wasn't started
    # with the -javaagent:/path-to-aspectj-weaver.jar option. If you are only using KamonStandalone
    # it might be ok for you to turn this error off.
    disable-aspectj-weaver-missing-error = false

    # Specify if entities that do not match any include/exclude filter should be tracked.
    track-unmatched-entities = yes

    filters {
      akka-actor {
        includes = ["*/user/*"]
        excludes = [ "*/system/**", "*/user/IO-**", "*kamon*" ]
      }

      akka-router {
        includes = ["*/user/*"]
        excludes = []
      }

      akka-dispatcher {
        includes = ["*/user/*"]
        excludes = []
      }

      trace {
        includes = [ "**" ]
        excludes = [ ]
      }
    }

    # Default instrument settings for histograms, min max counters and gaugues. The actual settings to be used when
    # creating a instrument is determined by merging the default settings, code settings and specific instrument
    # settings using the following priorities (top wins):

    #   - any setting in `kamon.metric.instrument-settings` for the given category/instrument.
    #   - code settings provided when creating the instrument.
    #   - `default-instrument-settings`.
    #
    default-instrument-settings {
      histogram {
        precision = normal
        lowest-discernible-value = 1
        highest-trackable-value = 3600000000000
      }

      min-max-counter {
        precision = normal
        lowest-discernible-value = 1
        highest-trackable-value = 999999999
        refresh-interval = 100 milliseconds
      }

      gauge {
        precision = normal
        lowest-discernible-value = 1
        highest-trackable-value = 3600000000000
        refresh-interval = 100 milliseconds
      }

    }

    # Custom configurations for category instruments. The settings provided in this section will override the default
    # and code instrument settings as explained in the `default-instrument-settings` key. There is no need to provide
    # full instrument settings in this section, only the settings that should be overriden must be included. Example:
    # if you wish to change the precision and lowest discernible value of the `elapsed-time` instrument for the `trace`
    # category, you should include the following configuration in your application.conf file:
    #
    #   kamon.metric.instrument-settings.trace {
    #     elapsed-time {
    #       precision = fine
    #       lowest-discernible-value = 1000
    #     }
    #   }
    #
    # In this example, the value for the `highest-trackable-value` setting will be either the code setting or the default
    # setting, depending on how the `elapsed-time` metric is created.
    instrument-settings {

    }
  }


  trace {

    # Level of detail used when recording trace information. The possible values are:
    #  - metrics-only: metrics for all included traces and all segments are recorded, but no Trace messages will be sent
    #    to the subscribers of trace data.
    #  - simple-trace: metrics for all included traces and all segments are recorded and additionally a Trace message
    #    containing the trace and segments details and metadata.
    level-of-detail = metrics-only

    # Sampling strategy to apply when the tracing level is set to `simple-trace`. The options are: all, random, ordered,
    # threshold and clock. The details of each sampler are below.
    sampling = random

    # Use a ThreadLocalRandom to generate numbers between 1 and 100, if the random number is less or equal to .chance
    # then tracing information will be gathered and reported for the current trace.
    random-sampler {
      chance = 10
    }

    # Use a AtomicLong to ensure that every .sample-interval number of requests tracing information will be gathered and
    # reported.
    ordered-sampler {
      # must be power of two
      sample-interval = 8
    }

    # Fully qualified name of the function that will be used for generating tokens to traces.
    token-generator = kamon.trace.DefaultTokenGenerator

    # Gather tracing information for all traces but only report those whose elapsed-time is equal or greated to the
    # .minimum-elapsed-time setting.
    threshold-sampler {
      minimum-elapsed-time = 1 second
    }

    # Use a FiniteDuration to only record a trace each .pause nanoseconds.
    clock-sampler {
      pause = 1 second
    }

    incubator {
      # Minimum time to stay in the trace incubator before checking if the trace should not be incubated anymore. No
      # checks are made at least until this period has passed.
      min-incubation-time = 5 seconds

      # Time to wait between incubation checks. After min-incubation-time, a trace is checked using this interval and if
      # if shouldn't be incubated anymore, the TraceInfo is collected and reported for it.
      check-interval = 1 second

      # Max amount of time that a trace can be in the incubator. If this time is reached for a given trace then it will
      # be reported with whatever information is available at the moment, logging a warning for each segment that remains
      # open after this point.
      max-incubation-time = 20 seconds
    }
  }


  # All settings included under the internal-config key will be used to repleace the akka.* and spray.* settings. By
  # doing this we avoid applying custom settings that might make sense for the user application to the internal actor
  # system and Spray facilities used by Kamon.
  internal-config {

    akka.actor.default-dispatcher {
      fork-join-executor {
        parallelism-min = 2
        parallelism-factor = 2.0
        parallelism-max = 10
      }
    }

    spray {

    }
  }

  # Controls whether the AspectJ Weaver missing warning should be displayed if any Kamon module requiring AspectJ is
  # found in the classpath but the application is started without the AspectJ Weaver.
  show-aspectj-missing-warning = yes

  akka {
    # If ask-pattern-timeout-warning is enabled, a WARN level log message will be generated if a future generated by the `ask`
    # pattern fails with a `AskTimeoutException` and the log message will contain information depending of the strategy selected.
    # strategies:
    #   - off: nothing to do.
    #   - lightweight: logs the warning when a timeout is reached using org.aspectj.lang.reflect.SourceLocation.
    #   - heavyweight: logs the warning when a timeout is reached using a stack trace captured at the moment the future was created.
    ask-pattern-timeout-warning = lightweight
  }


  statsd {

    # Hostname and port in which your StatsD is running. Remember that StatsD packets are sent using UDP and
    # setting unreachable hosts and/or not open ports wont be warned by the Kamon, your data wont go anywhere.
    hostname = "127.0.0.1"
    port = 8125

    # Interval between metrics data flushes to StatsD. It's value must be equal or greater than the
    # kamon.metric.tick-interval setting.
    flush-interval = 10 seconds

    # Max packet size for UDP metrics data sent to StatsD.
    max-packet-size = 1024 bytes

    # Subscription patterns used to select which metrics will be pushed to StatsD. Note that first, metrics
    # collection for your desired entities must be activated under the kamon.metrics.filters settings.
    subscriptions {
      histogram       = [ "**" ]
      min-max-counter = [ "**" ]
      gauge           = [ "**" ]
      counter         = [ "**" ]
      trace           = [ "**" ]
      trace-segment   = [ "**" ]
      akka-actor      = [ "**" ]
      akka-dispatcher = [ "**" ]
      akka-router     = [ "**" ]
      system-metric   = [ "**" ]
      http-server     = [ "**" ]
    }

    # FQCN of the implementation of `kamon.statsd.MetricKeyGenerator` to be instantiated and used for assigning
    # metric names. The implementation must have a single parameter constructor accepting a `com.typesafe.config.Config`.
    metric-key-generator = kamon.statsd.SimpleMetricKeyGenerator

    simple-metric-key-generator {

      # Application prefix for all metrics pushed to StatsD. The default namespacing scheme for metrics follows
      # this pattern:
      #    application.host.entity.entity-name.metric-name
      application = "yourapp"

      # Includes the name of the hostname in the generated metric. When set to false, the scheme for the metrics
      # will look as follows:
      #    application.entity.entity-name.metric-name
      include-hostname = true

      # Allow users to override the name of the hostname reported by kamon. When changed, the scheme for the metrics
      # will have the following pattern:
      #   application.hostname-override-value.entity.entity-name.metric-name
      hostname-override = none

      # When the sections that make up the metric names have special characters like dots (very common in dispatcher
      # names) or forward slashes (all actor metrics) we need to sanitize those values before sending them to StatsD
      # with one of the following strategies:
      #   - normalize: changes ': ' to '-' and ' ', '/' and '.' to '_'.
      #   - percent-encode: percent encode the section on the metric name. Please note that StatsD doesn't support
      #     percent encoded metric names, this option is only useful if using our docker image which has a patched
      #     version of StatsD or if you are running your own, customized version of StatsD that supports this.
      metric-name-normalization-strategy = normalize
    }
  }

  modules {
    kamon-log-reporter {
      auto-start = yes
      requires-aspectj = no
      extension-id = "kamon.logreporter.LogReporter"
    }
    kamon-system-metrics {
      auto-start = no # disabling system metrics temporarily for troubleshooting
      requires-aspectj = no
      extension-id = "kamon.system.SystemMetrics"
    }
    kamon-statsd {
      auto-start = yes
      requires-aspectj = no
      extension-id = "kamon.statsd.StatsD"
    }
    kamon-akka {
      auto-start = yes
      requires-aspectj = yes
      extension-id = "kamon.akka.Akka"
    }
  }

  system-metrics {

    # Sigar provisioner native library extract location. Use per-application-instance scoped location, such as program
    # working directory.
    sigar-native-folder = ${user.dir}"/native"

    # Frequency with which all Sigar-based metrics will be updated. Setting this value to less than 1 second
    # might cause some Sigar metrics to behave incorrectly.
    sigar-metrics-refresh-interval = 1 second

    #sigar is enabled by default
    sigar-enabled = true

    #jmx related metrics are enabled by default
    jmx-enabled = true

    # Frequency with which context-switches metrics will be updated.
    context-switches-refresh-interval = 1 second

    # Dispatcher to be used by the SigarMetricsUpdater actor.
    sigar-dispatcher {
      executor = "thread-pool-executor"
      type = PinnedDispatcher
    }

    # Dispatcher to be used by the ContextSwitchesUpdater actor.
    context-switches-dispatcher {
      executor = "thread-pool-executor"
      type = PinnedDispatcher
    }
  }

  metrics.instrument-settings {
    system-metric {

      #
      #   CPU
      #
      cpu-user {
        highest-trackable-value = 100
      }

      cpu-system = ${kamon.metrics.instrument-settings.system-metric.cpu-user}
      cpu-wait   = ${kamon.metrics.instrument-settings.system-metric.cpu-user}
      cpu-idle   = ${kamon.metrics.instrument-settings.system-metric.cpu-user}
      cpu-stolen = ${kamon.metrics.instrument-settings.system-metric.cpu-user}


      #
      #   Process CPU
      #
      process-user-cpu = ${kamon.metrics.instrument-settings.system-metric.cpu-user}
      process-system-cpu = ${kamon.metrics.instrument-settings.system-metric.cpu-user}
      process-cpu = ${kamon.metrics.instrument-settings.system-metric.cpu-user}


      #
      #   Garbage Collection
      #
      garbage-collection-count {
        highest-trackable-value = 1000000
        refresh-interval = 1 second
      }

      garbage-collection-time {
        highest-trackable-value = 3600000
        refresh-interval = 1 second
      }


      #
      #   Heap Memory
      #
      heap-used {
        # 50 GB, which is way too much for a non-Zing JVM
        highest-trackable-value = 5368709120
        refresh-interval = 1 second
      }

      heap-max       = ${kamon.metrics.instrument-settings.system-metric.heap-used}
      heap-committed = ${kamon.metrics.instrument-settings.system-metric.heap-used}


      #
      #   Non-Heap Memory
      #
      non-heap-used {
        highest-trackable-value = 5368709120
        refresh-interval = 1 second
      }
      non-heap-max        = ${kamon.metrics.instrument-settings.system-metric.non-heap-used}
      non-heap-committed  = ${kamon.metrics.instrument-settings.system-metric.non-heap-used}


      #
      #   JVM Threads
      #
      thread-count {
        highest-trackable-value = 10000
        refresh-interval = 1 second
      }

      daemon-thread-count = ${kamon.metrics.instrument-settings.system-metric.thread-count}
      peak-thread-count   = ${kamon.metrics.instrument-settings.system-metric.thread-count}


      #
      #   Class Loading
      #
      classes-loaded {
        highest-trackable-value = 10000000
        refresh-interval = 1 second
      }

      classes-unloaded          = ${kamon.metrics.instrument-settings.system-metric.classes-loaded}
      classes-currently-loaded  = ${kamon.metrics.instrument-settings.system-metric.classes-loaded}


      #
      #   File System
      #
      file-system-reads {
        highest-trackable-value = 107374182400
      }

      file-system-writes = ${kamon.metrics.instrument-settings.system-metric.file-system-reads}


      #
      #   Load Average
      #
      one-minute {
        highest-trackable-value = 10000
      }

      five-minutes    = ${kamon.metrics.instrument-settings.system-metric.one-minute}
      fifteen-minutes = ${kamon.metrics.instrument-settings.system-metric.one-minute}


      #
      #   System Memory
      #
      memory-used {
        highest-trackable-value = 5368709120
      }

      memory-free = ${kamon.metrics.instrument-settings.system-metric.memory-used}
      swap-free   = ${kamon.metrics.instrument-settings.system-metric.memory-used}
      swap-used   = ${kamon.metrics.instrument-settings.system-metric.memory-used}


      #
      #   Network
      #
      tx-bytes {
        highest-trackable-value = 107374182400
      }

      rx-bytes = ${kamon.metrics.instrument-settings.system-metric.tx-bytes}

      tx-errors {
        highest-trackable-value = 10000000
      }

      rx-errors   = ${kamon.metrics.instrument-settings.system-metric.tx-errors}
      tx-dropped  = ${kamon.metrics.instrument-settings.system-metric.tx-errors}
      rx-dropped  = ${kamon.metrics.instrument-settings.system-metric.tx-errors}


      #
      #   Context Switches
      #
      context-switches-process-voluntary {
        highest-trackable-value = 10000000
      }

      context-switches-process-non-voluntary = ${kamon.metrics.instrument-settings.system-metric.context-switches-process-voluntary}
      context-switches-global                = ${kamon.metrics.instrument-settings.system-metric.context-switches-process-voluntary}

    }
  }
}